import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Random;

// Exceção para indicar que o quarto está cheio
class QuartoCheioException extends Exception {
    public QuartoCheioException(String message) {
        super(message);
    }
}

// Exceção para indicar que o quarto está ocupado e não pode ser limpo
class QuartoOcupadoException extends Exception {
    public QuartoOcupadoException(String message) {
        super(message);
    }
}

class Quarto {
    private int numero;
    private boolean ocupado;
    private boolean limpo;
    private Queue<Hospede> filaEspera;
    private Hospede[] hospedes;
    private int numHospedes;

    public Quarto(int numero) {
        this.numero = numero;
        this.ocupado = false;
        this.limpo = true;
        this.filaEspera = new LinkedList<>();
        this.hospedes = new Hospede[4]; // Capacidade máxima de 4 hóspedes
        this.numHospedes = 0;
    }

    public synchronized void reservar(Hospede hospede) throws InterruptedException, QuartoCheioException {
        // Se o quarto estiver cheio ou estiver sendo limpo, coloque o hóspede na fila de espera
        while (ocupado || (limpo && numHospedes >= 4)) {
            if (!limpo) {
                System.out.println("Quarto " + numero + " está sendo limpo. " + hospede.getName() + " está aguardando.");
            } else {
                System.out.println("Quarto " + numero + " está cheio. " + hospede.getName() + " está aguardando.");
            }
            wait();
        }
        
        // Se o quarto não estiver cheio, reserve o quarto para o hóspede
        if (!ocupado) {
            hospedes[numHospedes++] = hospede;
            System.out.println(hospede.getName() + " reservou o Quarto " + numero + ".");
            if (numHospedes == 4) {
                ocupado = true;
                limpo = false;
                System.out.println("Quarto " + numero + " está cheio. Limpeza será realizada após a saída dos hóspedes.");
            }
            return;
        }

        // Se o quarto estiver ocupado, lance uma exceção de quarto cheio
        throw new QuartoCheioException("Quarto " + numero + " está cheio.");
    }

    public synchronized void desocupar() {
        for (int i = 0; i < 4; i++) {
            if (hospedes[i] != null) {
                System.out.println("Hóspede " + hospedes[i].getName() + " deixou o Quarto " + numero + ".");
                hospedes[i] = null;
            }
        }
        numHospedes = 0;
        ocupado = false;
        limpo = false; // O quarto não está limpo até que seja limpo novamente
        System.out.println("Quarto " + numero + " desocupado. Limpeza em andamento.");
        notifyAll();
    }

    public synchronized void limpar() throws QuartoOcupadoException {
        // Se o quarto estiver ocupado, lance uma exceção
        if (ocupado) {
            throw new QuartoOcupadoException("Quarto " + numero + " está ocupado e não pode ser limpo.");
        }
        
        // Limpe o quarto
        limpo = true;
        System.out.println("Quarto " + numero + " limpo e pronto para ocupação.");
        notifyAll();
    }

    public boolean isLimpo() {
        return limpo;
    }

    public boolean isOcupado() {
        return ocupado;
    }
}

class Hospede extends Thread {
    private static int count = 0;
    private int id;
    private List<Quarto> quartos;
    private Random random = new Random();
    private volatile boolean ativo;


    public Hospede(List<Quarto> quartos) {
        this.id = ++count;
        this.quartos = quartos;
        this.ativo = true;
    }

    public void parar() {
        this.ativo = false; // Método para parar a execução
    }

    @Override
    public void run() {
        while (this.ativo) {
            int quartoIndex = random.nextInt(quartos.size());
            Quarto quarto = quartos.get(quartoIndex);
            try {
                quarto.reservar(this);
                Thread.sleep(random.nextInt(5000)); // Hóspede permanece no quarto por um tempo
                quarto.desocupar();
                Thread.sleep(random.nextInt(10000)); // Hóspede realiza outras atividades antes de reservar novamente
                this.parar();
            } catch (InterruptedException | QuartoCheioException e) {
                e.printStackTrace();
            }
        }
    }
}
class Camareira extends Thread {
    private static int count = 0;
    private List<Quarto> quartos;
    private volatile boolean ativo;

    public Camareira(List<Quarto> quartos) {
        super("Camareira " + ++count);
        this.quartos = quartos;
        this.ativo = true;
    }

    public void parar() {
        this.ativo = false; // Método para parar a execução
    }

    @Override
    public void run() {
        while (this.ativo) {
            boolean todosLimpos = true;
            for (Quarto quarto : quartos) {
                synchronized (quarto) {
                    try {
                        quarto.limpar();
                    } catch (QuartoOcupadoException e) {
                        // O quarto está ocupado, continue para o próximo quarto
                        todosLimpos = false;
                        continue;
                    }
                }
            }
            if (todosLimpos) {
                this.parar();
            }
            try {
                Thread.sleep(10000); // Camareira leva algum tempo para limpar os quartos
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Recepcionista extends Thread {
    private static int count = 0;
    private List<Quarto> quartos;
    private Queue<Hospede> filaEspera;
    private volatile boolean ativo;

    public Recepcionista(List<Quarto> quartos, Queue<Hospede> filaEspera) {
        super("Recepcionista " + ++count);
        this.quartos = quartos;
        this.filaEspera = filaEspera;
        this.ativo = true;
    }

    public void parar() {
        this.ativo = false; // Método para parar a execução
    }

    public synchronized void reservarQuarto(Hospede hospede) throws QuartoCheioException {
        for (Quarto quarto : quartos) {
            synchronized (quarto) {
                try {
                    quarto.reservar(hospede);
                    return;
                } catch (QuartoCheioException e) {
                    // O quarto está cheio, continue para o próximo quarto
                    continue;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        // Todos os quartos estão cheios, adicione o hóspede à fila de espera
        filaEspera.offer(hospede);
        System.out.println("Hóspede " + hospede.getName() + " adicionado à fila de espera.");
    }

    @Override
    public void run() {
        while (this.ativo) {
            synchronized (filaEspera) {
                while (!filaEspera.isEmpty()) {
                    Hospede hospede = filaEspera.poll();
                    try {
                        reservarQuarto(hospede);
                    } catch (QuartoCheioException e) {
                        // Hóspede tentou reservar um quarto duas vezes sem sucesso, deixe uma reclamação e vá embora
                        System.out.println("Hóspede " + hospede.getName() + " deixou uma reclamação e foi embora.");
                    }
                }
            }
            if (filaEspera.isEmpty()) {
                this.parar();
            }
            try {
                Thread.sleep(5000); // Recepcionista leva algum tempo para atender os hóspedes
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

}

public class HotelSimulation {
    public static void main(String[] args) {
        // Criação de quartos, fila de espera e listas de threads
        List<Quarto> quartos = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            quartos.add(new Quarto(i));
        }

        Queue<Hospede> filaEspera = new LinkedList<>();

        List<Thread> threads = new ArrayList<>();

        // Criação e inicialização de hóspedes
        for (int i = 0; i < 50; i++) {
            threads.add(new Hospede(quartos));
        }

        // Criação e inicialização de camareiras
        for (int i = 0; i < 10; i++) {
            threads.add(new Camareira(quartos));
        }

        // Criação e inicialização de recepcionistas
        for (int i = 0; i < 5; i++) {
            threads.add(new Recepcionista(quartos, filaEspera));
        }

        // Inicialização de todas as threads
        for (Thread thread : threads) {
            thread.start();
        }
    }
}
